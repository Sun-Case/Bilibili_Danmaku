## Bilibiliç½‘é¡µç‰ˆ å†å²å¼¹å¹• è§£æ

* æè¿™ä¸ªåªæ˜¯å…´è¶£é©±åŠ¨ï¼ŒåŠ ä¸Šæ²¡å­¦è¿‡ç¼–ç¨‹ã€ç®—æ³•ä¹‹ç±»çš„ï¼Œæ‰€ä»¥ä½¿ç”¨è¿‡ç¨‹ä¸­å‡ºç°é—®é¢˜ï¼Œè¿˜è¯·è‡ªå·±å…ˆçœ‹çœ‹èƒ½å¦è§£å†³ğŸ˜Šï¼Œé—®æˆ‘åæœ‰å…«ä¹éƒ½ä¸ä¼š
* æˆªè‡³ 2021.06.30 è¿˜èƒ½ç”¨

### å‰è¨€
å¥½ä¹…æ²¡å¼„å†å²å¼¹å¹•ï¼Œæœ€è¿‘æä¸œè¥¿ï¼Œéœ€è¦å†å²å¼¹å¹•ï¼Œå‘ç°Bç«™æ›´æ–°äº†API  
`https://api.bilibili.com/x/v2/dm/web/history/seg.so?type=1&oid=CIDå·&date=å¹´-æœˆ-æ—¥`  
å…¶å®æ—§APIä¹Ÿå¯ä»¥ç”¨ï¼š`https://api.bilibili.com/x/v1/dm/list.so?oid=CIDå·&date=å¹´-æœˆ-æ—¥`  
ä¸Šç½‘æœäº†ä¸€ä¸‹ï¼Œå‘ç°ä¼¼ä¹æ²¡äººå¯¹æ–°APIçš„æ•°æ®è¿›è¡Œåˆ†æ  

åŸæœ¬å°±å°±æ­¤ä¸ºæ­¢ã€‚  
ä½†å› ä¸ºç–«æƒ…åŸå› è¢«éš”ç¦»äº†ï¼Œé—²ç€ä¹Ÿæ˜¯é—²ç€ï¼Œæ—¢ç„¶æœ‰æ–°çš„APIï¼Œå°±è¯•è¯•çœ‹è‡ªå·±èƒ½ä¸èƒ½æ‰¾å‡ºè§£æä»£ç   
äºæ˜¯è¯´å¹²å°±å¹²ï¼Œä¸€ä¸ªæ™šä¸Š+ä¸€ä¸ªä¸Šåˆï¼Œç¡¬æ˜¯æŠŠä¸»è¦çš„ä»£ç æ‰¾å‡ºæ¥äº†ï¼Œç„¶åæ¨¡ä»¿è¿™ä¸ªä»£ç ï¼Œè‡ªå·±å†™äº†ä¸€ä¸ªè‡ªå·±èƒ½çœ‹æ‡‚çš„å…¥é—¨ä»£ç 

### è¯´æ˜
- [jsc-player](data/2021.06.30/jsc-player.571ab0b4.js)
  - Bç«™è·å–å¼¹å¹•çš„åŸå§‹ä»£ç 
- [jsc-vendors_player.js](data/2021.06.30/jsc-vendors~player.7f77f81a.js)
  - Bç«™è§£æå¼¹å¹•çš„åŸå§‹ä»£ç 
- [formatted.jsc-player.js](data/2021.06.30/formatted.jsc-player.571ab0b4.js)
  - æ ¼å¼åŒ–åä»£ç 
- [formatted.jsc-vendors~player.js](data/2021.06.30/formatted.jsc-vendors~player.7f77f81a.js)
  - æ ¼å¼åŒ–åä»£ç 

è·å–å¼¹å¹•åŸå§‹æ•°æ®å¹¶è°ƒç”¨è§£æå‡½æ•°çš„ä»£ç ä¸»è¦åœ¨ [jsc-player.js](data/2021.06.30/formatted.jsc-player.571ab0b4.js) çš„ [ç¬¬43130è¡Œ](data/2021.06.30/formatted.jsc-player.571ab0b4.js#L43130) åˆ° [ç¬¬43150è¡Œ](data/2021.06.30/formatted.jsc-player.571ab0b4.js#L43150)  
è§£æå¼¹å¹•çš„ä»£ç ä¸»è¦åœ¨ [jsc-vendors~player.js](data/2021.06.30/formatted.jsc-vendors~player.7f77f81a.js) çš„ [ç¬¬4212è¡Œ](data/2021.06.30/formatted.jsc-vendors~player.7f77f81a.js#L4212) åˆ° [ç¬¬4426è¡Œ](data/2021.06.30/formatted.jsc-vendors~player.7f77f81a.js#L4426)

æˆ‘å½“æ—¶æ˜¯ä» [jsc-player.js ç¬¬43139è¡Œ](data/2021.06.30/formatted.jsc-player.571ab0b4.js#L43139) å¼€å§‹ï¼Œæ­¤å¤„æ˜¯è·å–è§£æåçš„æ•°æ®ï¼ˆå³å·²ç»æ•´ç†å¥½å¼¹å¹•å†…å®¹ã€æ—¶é—´ä¹‹ç±»çš„ï¼Œå¯ç›´æ¥ä½¿ç”¨ï¼‰ã€‚ç„¶åå›æº¯ã€‚æœ€ç»ˆæ‰¾åˆ°æ‰€éœ€çš„ä»£ç ã€‚

### JavaScript ä»£ç 
ä¸è¦ç›´æ¥å¤åˆ¶ç²˜è´´è¿è¡Œï¼Œè¯·å°†ä»£ç å†…çš„ `url` è®¾ç½®å¥½å†ä¸¢åˆ°æ§åˆ¶å°æ‰§è¡Œ
<details>
<summary>ç‚¹å‡»å±•å¼€</summary>

```js
class Reader {
    offset = 0
    length = 0
    u8a = []
    constructor(u8a) {
        this.length = u8a.length;
        this.u8a = u8a;
        return this;
    }

    uint32() {
        let l = 4294967295;
        l = (127 & this.u8a[this.offset]) >>> 0;
        if (this.u8a[this.offset++] < 128) {
            return l;
        }

        l = (l | (127 & this.u8a[this.offset]) << 7) >>> 0;
        if (this.u8a[this.offset++] < 128) {
            return l;
        }

        l = (l | (127 & this.u8a[this.offset]) << 14) >>> 0;
        if (this.u8a[this.offset++] < 128) {
            return l;
        }

        l = (l | (127 & this.u8a[this.offset]) << 21) >>> 0;
        if (this.u8a[this.offset++] < 128) {
            return l;
        }

        l = (l | (15 & this.u8a[this.offset]) << 28) >>> 0;
        if (this.u8a[this.offset++] < 128) {
            return l;
        }

        this.offset += 5;
        if (this.offset > this.length) {
            this.offset = this.length;
            throw RangeError("index out of range: " + this.offset + " + " + (10 || 1) + " > " + this.length);
        }

        return l;
    }

    int32() {
        return 0 | this.uint32();
    }

    int64() {
        let t = { lo: 0, hi: 0 };
        let e = 0;
        if (this.length - this.offset <= 4) {
            for (; e < 3; ++e) {
                if (this.offset >= this.length) {
                    throw RangeError("index out of range: " + this.offset + " + " + 1 + " > " + this.length);
                }
                t.lo = (t.lo | (127 & this.u8a[this.offset]) << 7 * e) >>> 0;
                if (this.u8a[this.offset++] < 128) {
                    return this.toNumber(1, t);
                }
            }
            t.lo = (t.lo | (127 & this.u8a[this.offset++]) << 7 * e) >>> 0;
            return this.toNumber(1, t);
        }
        for (; e < 4; ++e) {
            t.lo = (t.lo | (127 & this.u8a[this.offset]) << 7 * e) >>> 0;
            if (this.u8a[this.offset++] < 128) {
                return this.toNumber(1, t);
            }
        }
        t.lo = (t.lo | (127 & this.u8a[this.offset]) << 28) >>> 0;
        t.hi = (t.hi | (127 & this.u8a[this.offset]) >> 4) >>> 0;
        if (this.u8a[this.offset++] < 128) {
            return this.toNumber(1, t);
        }

        e = 0;
        if (this.length - this.offset > 4) {
            for (; e < 5; ++e) {
                t.hi = (t.hi | (127 & this.u8a[this.offset]) << 7 * e + 3) >>> 0;
                if (this.u8a[this.offset++] < 128) {
                    return this.toNumber(1, t);
                }
            }
        } else {
            for (; e < 5; ++e) {
                if (this.offset >= this.length) {
                    throw RangeError("index out of range: " + this.offset + " + " + 1 + " > " + this.length);
                }
                t.hi = (t.hi | (127 & this.u8a[this.offset]) << 7 * e + 3) >>> 0;
                if (this.u8a[this.offset++] < 128) {
                    return this.toNumber(1, t);
                }
            }
        }
        throw Error("invalid varint encoding");
    }

    bytes() {
        let t = this.uint32();
        let e = this.offset;
        let i = this.offset + t;
        if (i > this.length) {
            throw RangeError("index out of range: " + this.offset + " + " + (t || 1) + " > " + this.length);
        }
        this.offset += t;
        return this.u8a.slice(e, i);
    }

    string() {
        let t = this.bytes();
        let i = t.length;
        let e = 0;
        if (i - e < 1)
            return "";

        if (i < 1) {
            return "";
        }
        let r;
        let n = null;
        let a = [];
        let o = 0;
        for (; e < i;) {
            r = t[e++];
            if (r < 128) {
                a[o++] = r;
            } else if (r > 191 && r < 224) {
                a[o++] = (31 & r) << 6 | 63 & t[e++];
            } else if (r > 239 && r < 365) {
                r = ((7 & r) << 18 | (63 & t[e++]) << 12 | (63 & t[e++]) << 6 | 63 & t[e++]) - 65536;
                a[o++] = 55296 + (r >> 10);
                a[o++] = 56320 + (1023 & r);
            } else {
                a[o++] = (15 & r) << 12 | (63 & t[e++]) << 6 | 63 & t[e++];
                if (o > 8191) {
                    n = n || [];
                    n.push(String.fromCharCode.apply(String, a));
                    o = 0;
                }
            }
        }
        return n ? (o && n.push(String.fromCharCode.apply(String, a.slice(0, o))),
            n.join("")) : String.fromCharCode.apply(String, a.slice(0, o));
    }

    toNumber(flag, t) {
        if (flag && t.hi >>> 31) {
            let e = 1 + ~t.lo >>> 0;
            let i = ~t.hi >>> 0;
            if (!e) {
                i = i + 1 >>> 0;
            }
            return -(e + 4294967296 * i);
        }
        return t.lo + 4294967296 * t.hi;
    }

    skip(t) {
        if ("number" == typeof t) {
            if (this.offset + t > this.length) {
                throw RangeError("index out of range: " + this.offset + " + " + (t || 1) + " > " + this.length);
            }
            this.offset += t;
        } else {
            do {
                if (this.offset >= this.length) {
                    throw RangeError("index out of range: " + this.offset + " + " + 1 + " > " + this.length);
                }
            } while (128 & this.u8a[this.offset++]);
        }
        return this;
    }
    skipType(t) {
        switch (t) {
            case 0: {
                this.skip();
                break;
            }
            case 1: {
                this.skip(8);
                break;
            }
            case 2: {
                this.skip(this.uint32());
                break;
            }
            case 3: {
                while (1) {
                    t = 7 & this.uint32();
                    if (4 != t) {
                        this.skip(t);
                    } else {
                        break;
                    }
                }
                break;
            }
            case 5: {
                this.skip(4);
                break;
            }
            default: {
                throw Error("invalid wire type " + t + " at offset " + this.offset);
            }
        }
        return this;
    }
}

function DanmakuDecode(u8a) {
    let M = [];
    let r = new Reader(u8a);
    while (r.offset < r.length) {
        let u32 = r.uint32();

        switch (u32 >>> 3) {
            case 1: {
                (function (offs) {
                    let m = {};
                    let c = r.offset + offs;
                    while (r.offset < c) {
                        let t = r.uint32();
                        switch (t >>> 3) {
                            case 1: {
                                m.id = r.int64();
                                break;
                            }
                            case 2: {
                                m.progress = r.int32();
                                break;
                            }
                            case 3: {
                                m.mode = r.int32();
                                break;
                            }
                            case 4: {
                                m.fontsize = r.int32();
                                break;
                            }
                            case 5: {
                                m.color = r.uint32();
                                break;
                            }
                            case 6: {
                                m.midHash = r.string();
                                break;
                            }
                            case 7: {
                                m.content = r.string();
                                break;
                            }
                            case 8: {
                                m.ctime = r.int64();
                                break;
                            }
                            case 9: {
                                m.weight = r.int32();
                                break;
                            }
                            case 10: {
                                m.action = r.string();
                                break;
                            }
                            case 11: {
                                m.pool = r.int32();
                                break;
                            }
                            case 12: {
                                m.idStr = r.string();
                                break;
                            }
                            case 13: {
                                m.attr = r.int32();
                                break;
                            }
                            default: {
                                r.skipType(t & 7);
                                break;
                            }
                        }
                    }
                    M.push(m);
                })(r.uint32());
                break;
            }
            default: {
                r.skipType(t & 7);
                break;
            }
        }
    }
    return M;
}

var url = "https://api.bilibili.com/x/v2/dm/web/history/seg.so?type=1&oid=è§†é¢‘çš„CIDå·&date=å¹´-æœˆï¼ˆä¸¤ä½æ•°ï¼‰-æ—¥ï¼ˆä¸¤ä½æ•°ï¼‰";

var xhr = new XMLHttpRequest;
xhr.open("GET", url);
xhr.responseType = "arraybuffer";
xhr.withCredentials = true;
xhr.addEventListener("load", function () {
    let u8a = new Uint8Array(this.response);
    window.M = DanmakuDecode(u8a);
});
xhr.send();
```
</details>

---

2021.06.30
